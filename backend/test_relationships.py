#!/usr/bin/env python3
"""
Test de validation des relations entre les donn√©es SQLite
"""

import json
from datetime import datetime
from database import db_manager
from database_service import db_service

def test_building_tenant_relationships():
    """Tester les relations immeubles-locataires"""
    print("üè¢ TEST DES RELATIONS IMMEUBLES-LOCATAIRES")
    print("=" * 50)
    
    try:
        # 1. Cr√©er un immeuble
        print("1Ô∏è‚É£ Cr√©ation d'un immeuble...")
        building_data = {
            "name": "Immeuble Test Relations",
            "address": {
                "street": "123 Rue Test",
                "city": "Montr√©al",
                "province": "QC",
                "postalCode": "H1A 1A1",
                "country": "Canada"
            },
            "type": "R√©sidentiel",
            "units": 3,
            "floors": 2,
            "yearBuilt": 2023,
            "totalArea": 800,
            "notes": "Immeuble de test pour les relations"
        }
        
        building = db_service.create_building(building_data)
        building_id = building["id"]
        print(f"‚úÖ Immeuble cr√©√© avec ID: {building_id}")
        
        # 2. Cr√©er des locataires
        print("\n2Ô∏è‚É£ Cr√©ation de locataires...")
        tenants_data = [
            {
                "name": "Jean Dupont",
                "email": "jean.dupont@test.com",
                "phone": "(514) 555-0001",
                "status": "active",
                "notes": "Locataire test 1"
            },
            {
                "name": "Marie Martin",
                "email": "marie.martin@test.com",
                "phone": "(514) 555-0002",
                "status": "active",
                "notes": "Locataire test 2"
            }
        ]
        
        tenant_ids = []
        for tenant_data in tenants_data:
            tenant = db_service.create_tenant(tenant_data)
            tenant_ids.append(tenant["id"])
            print(f"‚úÖ Locataire cr√©√© avec ID: {tenant['id']} - {tenant['name']}")
        
        # 3. Cr√©er des assignations (relations)
        print("\n3Ô∏è‚É£ Cr√©ation d'assignations...")
        assignments_data = [
            {
                "tenantId": tenant_ids[0],
                "buildingId": building_id,
                "unitId": "101",
                "unitNumber": "101",
                "unitAddress": "123 Rue Test, Montr√©al, QC",
                "moveInDate": datetime.now().isoformat(),
                "rentAmount": 1200.00,
                "depositAmount": 600.00,
                "leaseStartDate": datetime.now().isoformat(),
                "leaseEndDate": (datetime.now().replace(year=datetime.now().year + 1)).isoformat(),
                "rentDueDay": 1,
                "notes": "Assignation test 1"
            },
            {
                "tenantId": tenant_ids[1],
                "buildingId": building_id,
                "unitId": "102",
                "unitNumber": "102",
                "unitAddress": "123 Rue Test, Montr√©al, QC",
                "moveInDate": datetime.now().isoformat(),
                "rentAmount": 1300.00,
                "depositAmount": 650.00,
                "leaseStartDate": datetime.now().isoformat(),
                "leaseEndDate": (datetime.now().replace(year=datetime.now().year + 1)).isoformat(),
                "rentDueDay": 1,
                "notes": "Assignation test 2"
            }
        ]
        
        assignment_ids = []
        for assignment_data in assignments_data:
            assignment = db_service.create_assignment(assignment_data)
            assignment_ids.append(assignment["id"])
            print(f"‚úÖ Assignation cr√©√©e avec ID: {assignment['id']}")
        
        # 4. V√©rifier les relations
        print("\n4Ô∏è‚É£ V√©rification des relations...")
        
        # R√©cup√©rer l'immeuble avec ses relations
        building_with_relations = db_service.get_building(building_id)
        print(f"‚úÖ Immeuble r√©cup√©r√©: {building_with_relations['name']}")
        
        # R√©cup√©rer les locataires
        tenants = db_service.get_tenants()
        print(f"‚úÖ {len(tenants)} locataires trouv√©s")
        
        # R√©cup√©rer les assignations
        assignments = db_service.get_assignments()
        print(f"‚úÖ {len(assignments)} assignations trouv√©es")
        
        # V√©rifier la coh√©rence des donn√©es
        print("\n5Ô∏è‚É£ V√©rification de la coh√©rence...")
        
        # V√©rifier que les assignations pointent vers des locataires existants
        for assignment in assignments:
            tenant_id = assignment.get('tenantId')
            if tenant_id:
                tenant = db_service.get_tenant(tenant_id)
                if tenant:
                    print(f"‚úÖ Assignation {assignment['id']} ‚Üí Locataire {tenant['name']}")
                else:
                    print(f"‚ùå Assignation {assignment['id']} ‚Üí Locataire {tenant_id} INEXISTANT")
        
        print("\nüéâ TEST DES RELATIONS R√âUSSI !")
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur lors du test des relations: {e}")
        import traceback
        traceback.print_exc()
        return False

def test_data_integrity():
    """Tester l'int√©grit√© des donn√©es"""
    print("\nüîç TEST D'INT√âGRIT√â DES DONN√âES")
    print("=" * 50)
    
    try:
        # V√©rifier les contraintes de cl√©s √©trang√®res
        print("1Ô∏è‚É£ V√©rification des contraintes de cl√©s √©trang√®res...")
        if db_manager.connect():
            cursor = db_manager.connection.cursor()
            cursor.execute("PRAGMA foreign_key_check")
            fk_errors = cursor.fetchall()
            
            if fk_errors:
                print(f"‚ùå {len(fk_errors)} violations de cl√©s √©trang√®res trouv√©es")
                for error in fk_errors:
                    print(f"   - {error}")
                return False
            else:
                print("‚úÖ Aucune violation de cl√©s √©trang√®res")
            
            db_manager.disconnect()
        
        # V√©rifier la coh√©rence des donn√©es
        print("\n2Ô∏è‚É£ V√©rification de la coh√©rence des donn√©es...")
        
        # Compter les enregistrements
        buildings = db_service.get_buildings()
        tenants = db_service.get_tenants()
        assignments = db_service.get_assignments()
        
        print(f"   üìä Immeubles: {len(buildings)}")
        print(f"   üë• Locataires: {len(tenants)}")
        print(f"   üîó Assignations: {len(assignments)}")
        
        # V√©rifier que les assignations pointent vers des locataires existants
        orphaned_assignments = 0
        for assignment in assignments:
            tenant_id = assignment.get('tenantId')
            if tenant_id:
                tenant = db_service.get_tenant(tenant_id)
                if not tenant:
                    orphaned_assignments += 1
                    print(f"   ‚ö†Ô∏è Assignation orpheline: {assignment['id']} ‚Üí Locataire {tenant_id} inexistant")
        
        if orphaned_assignments == 0:
            print("‚úÖ Aucune assignation orpheline")
        else:
            print(f"‚ùå {orphaned_assignments} assignations orphelines")
            return False
        
        print("\nüéâ TEST D'INT√âGRIT√â R√âUSSI !")
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur lors du test d'int√©grit√©: {e}")
        return False

def test_crud_operations():
    """Tester les op√©rations CRUD"""
    print("\nüîÑ TEST DES OP√âRATIONS CRUD")
    print("=" * 50)
    
    try:
        # Test CREATE
        print("1Ô∏è‚É£ Test CREATE...")
        building_data = {
            "name": "Immeuble CRUD Test",
            "address": {
                "street": "456 Rue CRUD",
                "city": "Montr√©al",
                "province": "QC",
                "postalCode": "H2B 2B2",
                "country": "Canada"
            },
            "type": "Commercial",
            "units": 5,
            "floors": 3,
            "yearBuilt": 2024,
            "totalArea": 1200,
            "notes": "Test CRUD"
        }
        
        building = db_service.create_building(building_data)
        building_id = building["id"]
        print(f"‚úÖ CREATE r√©ussi - ID: {building_id}")
        
        # Test READ
        print("\n2Ô∏è‚É£ Test READ...")
        retrieved_building = db_service.get_building(building_id)
        if retrieved_building and retrieved_building["name"] == "Immeuble CRUD Test":
            print("‚úÖ READ r√©ussi")
        else:
            print("‚ùå READ √©chou√©")
            return False
        
        # Test UPDATE
        print("\n3Ô∏è‚É£ Test UPDATE...")
        update_data = {"name": "Immeuble CRUD Test Modifi√©"}
        updated_building = db_service.update_building(building_id, update_data)
        if updated_building and updated_building["name"] == "Immeuble CRUD Test Modifi√©":
            print("‚úÖ UPDATE r√©ussi")
        else:
            print("‚ùå UPDATE √©chou√©")
            return False
        
        # Test DELETE
        print("\n4Ô∏è‚É£ Test DELETE...")
        success = db_service.delete_building(building_id)
        if success:
            print("‚úÖ DELETE r√©ussi")
        else:
            print("‚ùå DELETE √©chou√©")
            return False
        
        # V√©rifier que l'immeuble est supprim√©
        deleted_building = db_service.get_building(building_id)
        if deleted_building is None:
            print("‚úÖ V√©rification suppression r√©ussie")
        else:
            print("‚ùå L'immeuble n'a pas √©t√© supprim√©")
            return False
        
        print("\nüéâ TEST CRUD R√âUSSI !")
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur lors du test CRUD: {e}")
        return False

def test_data_consistency():
    """Tester la coh√©rence des donn√©es"""
    print("\nüìä TEST DE COH√âRENCE DES DONN√âES")
    print("=" * 50)
    
    try:
        # Cr√©er des donn√©es de test avec relations
        print("1Ô∏è‚É£ Cr√©ation de donn√©es de test...")
        
        # Immeuble
        building = db_service.create_building({
            "name": "Immeuble Coh√©rence",
            "address": {"street": "789 Rue Coh√©rence", "city": "Montr√©al", "province": "QC", "postalCode": "H3C 3C3", "country": "Canada"},
            "type": "R√©sidentiel",
            "units": 2,
            "floors": 1,
            "yearBuilt": 2023,
            "totalArea": 600,
            "notes": "Test coh√©rence"
        })
        
        # Locataires
        tenant1 = db_service.create_tenant({
            "name": "Alice Test",
            "email": "alice@test.com",
            "phone": "(514) 555-1001",
            "status": "active"
        })
        
        tenant2 = db_service.create_tenant({
            "name": "Bob Test",
            "email": "bob@test.com",
            "phone": "(514) 555-1002",
            "status": "active"
        })
        
        # Assignations
        assignment1 = db_service.create_assignment({
            "tenantId": tenant1["id"],
            "buildingId": building["id"],
            "unitId": "201",
            "unitNumber": "201",
            "unitAddress": "456 Rue Coh√©rence, Montr√©al, QC",
            "moveInDate": datetime.now().isoformat(),
            "rentAmount": 1400.00,
            "depositAmount": 700.00,
            "leaseStartDate": datetime.now().isoformat(),
            "leaseEndDate": (datetime.now().replace(year=datetime.now().year + 1)).isoformat(),
            "rentDueDay": 1,
            "notes": "Test coh√©rence 1"
        })
        
        assignment2 = db_service.create_assignment({
            "tenantId": tenant2["id"],
            "buildingId": building["id"],
            "unitId": "202",
            "unitNumber": "202",
            "unitAddress": "456 Rue Coh√©rence, Montr√©al, QC",
            "moveInDate": datetime.now().isoformat(),
            "rentAmount": 1500.00,
            "depositAmount": 750.00,
            "leaseStartDate": datetime.now().isoformat(),
            "leaseEndDate": (datetime.now().replace(year=datetime.now().year + 1)).isoformat(),
            "rentDueDay": 1,
            "notes": "Test coh√©rence 2"
        })
        
        print("‚úÖ Donn√©es de test cr√©√©es")
        
        # V√©rifier la coh√©rence
        print("\n2Ô∏è‚É£ V√©rification de la coh√©rence...")
        
        # V√©rifier que les assignations pointent vers des locataires existants
        assignments = db_service.get_assignments()
        for assignment in assignments:
            tenant_id = assignment.get('tenantId')
            if tenant_id:
                tenant = db_service.get_tenant(tenant_id)
                if tenant:
                    print(f"‚úÖ Assignation {assignment['id']} ‚Üí Locataire {tenant['name']}")
                else:
                    print(f"‚ùå Assignation {assignment['id']} ‚Üí Locataire {tenant_id} INEXISTANT")
                    return False
        
        # V√©rifier que les donn√©es sont coh√©rentes
        print("\n3Ô∏è‚É£ V√©rification des donn√©es...")
        
        # Compter les enregistrements
        buildings = db_service.get_buildings()
        tenants = db_service.get_tenants()
        assignments = db_service.get_assignments()
        
        print(f"   üìä Immeubles: {len(buildings)}")
        print(f"   üë• Locataires: {len(tenants)}")
        print(f"   üîó Assignations: {len(assignments)}")
        
        # V√©rifier que les relations sont correctes
        if len(assignments) >= 2 and len(tenants) >= 2:
            print("‚úÖ Relations correctes")
        else:
            print("‚ùå Relations incorrectes")
            return False
        
        print("\nüéâ TEST DE COH√âRENCE R√âUSSI !")
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur lors du test de coh√©rence: {e}")
        return False

def main():
    """Fonction principale de test"""
    print("üß™ TEST COMPLET DE LA LOGIQUE SQL ET DES RELATIONS")
    print("=" * 70)
    
    tests = [
        ("Relations immeubles-locataires", test_building_tenant_relationships),
        ("Int√©grit√© des donn√©es", test_data_integrity),
        ("Op√©rations CRUD", test_crud_operations),
        ("Coh√©rence des donn√©es", test_data_consistency)
    ]
    
    success_count = 0
    
    for test_name, test_func in tests:
        print(f"\n{'='*20} {test_name} {'='*20}")
        if test_func():
            success_count += 1
            print(f"‚úÖ {test_name}: R√âUSSI")
        else:
            print(f"‚ùå {test_name}: √âCHOU√â")
    
    print(f"\nüìä R√âSULTATS: {success_count}/{len(tests)} tests r√©ussis")
    
    if success_count == len(tests):
        print("\nüéâ TOUS LES TESTS R√âUSSIS !")
        print("‚úÖ La logique SQL fonctionne correctement")
        print("‚úÖ Les relations entre donn√©es sont pr√©serv√©es")
        print("‚úÖ L'int√©grit√© des donn√©es est assur√©e")
        print("‚úÖ Les op√©rations CRUD fonctionnent")
        print("‚úÖ La coh√©rence des donn√©es est maintenue")
    else:
        print("\n‚ö†Ô∏è Certains tests ont √©chou√©")
        print("‚ùå V√©rifiez les erreurs ci-dessus")

if __name__ == "__main__":
    main()
